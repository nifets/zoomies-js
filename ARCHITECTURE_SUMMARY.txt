================================================================================
CLEAN ARCHITECTURE SUMMARY - OPTION A IMPLEMENTATION
================================================================================

OBJECTIVE:
  Implement explicit presentation modes with single source of truth.
  All visibility/opacity/positioning derives from mode, not calculated independently.

================================================================================
RESPONSIBILITY BOUNDARIES (AFTER REFACTOR)
================================================================================

ScaleBar.ts (Coordinate & Window Management)
  INPUT: Layer hierarchy, scale factors
  OUTPUT: Layer positions, windows, segment boundaries
  JOB: Geometry calculations only, window boundaries in zoom space
  
  Public API:
    ✓ getOptimalZoomForLayer(layer) → number
    ✓ getLayerWindowZoom(layer) → { minZoom, maxZoom }
    ✓ getLayerWindowSegments(layer) → LayerWindowSegments (5 boundaries)
    ✓ getLayerWindow(layer) → { minScale, maxScale } (backward compat)
  
  Lifecycle: Built once at graph init, never changes


LayerDetailManager.ts (Visibility & Presentation State)
  INPUT: Camera zoomLevel, Entity, Zoom-based window segments
  OUTPUT: DetailState { visible, opacity, background, label, children, border }
  JOB: Determine mode, derive all properties from mode
  
  Logic Flow:
    1. Get window segments from ScaleBar
    2. Determine presentation mode (where in window is entity?)
    3. For each property, ask: what should this be in MODE X?
    4. Return complete DetailState
  
  New Enum:
    INVISIBLE → not rendered
    FADING_IN → entering from zoomed-in side
    EXPANDED → at optimal, full detail, children visible
    COLLAPSING → transitioning to next layer, collapsing
    FADING_OUT → leaving towards zoomed-out side


Renderer.ts (Visual Output)
  INPUT: Entity, DetailState
  OUTPUT: Graphics on screen
  JOB: Apply DetailState properties mechanically, no logic
  
  Pure Application:
    • graphics.alpha = detailState.opacity
    • shape.draw(..., detailState.backgroundOpacity, ...)
    • if (detailState.showBorder) { ... }
    • labelInside = detailState.labelInside
  
  REMOVE:
    ✗ getChildNodeOpacity() method (no visibility logic in Renderer!)
    ✗ Any fallback or conditional logic
    ✗ Any calculations based on current zoom


LabelRenderer.ts (Label Positioning Helper)
  INPUT: Entity, labelInside boolean (from DetailState)
  OUTPUT: Position and font size
  JOB: Convert mode to coordinates
  
  Deterministic:
    if (labelInside) { center on node }
    else { above node }

================================================================================
PRESENTATION MODE → PROPERTY MAPPING
================================================================================

Mode:         | visible | opacity | background | label    | children | border
INVISIBLE     | false   | 0       | 0          | -        | false    | false
FADING_IN     | true    | 0→1     | 0          | outside  | false    | false
EXPANDED      | true    | 1.0     | 0.15       | outside  | true     | true
COLLAPSING    | true    | 1→0     | 1.0        | inside   | false    | true
FADING_OUT    | true    | 0→1     | 1.0        | inside   | false    | false

All properties determined by mode - no independent calculation!

================================================================================
IMPLEMENTATION PHASES
================================================================================

Phase 1: ScaleBar Foundation
  □ Add LayerWindowSegments interface (5 boundaries in zoom)
  □ Implement computeAllLayerWindows() (global constraint solving)
  □ Add getLayerWindowSegments(layer)
  □ Add getLayerWindowZoom(layer)
  
  Status: ScaleBar provides both zoom and scale APIs

Phase 2: Mode System
  □ Define PresentationMode enum (INVISIBLE, FADING_IN, EXPANDED, etc.)
  □ Implement determinePresentationMode(zoomLevel, segments)
  □ Implement mode→property helper methods
  
  Status: Mode system in place, properties derive from mode

Phase 3: LayerDetailManager Refactor
  □ Rewrite getDetailStateAtZoom() to use mode system
  □ Remove fade-parameter-based calculations
  □ Ensure LayerDetailManager is SOLE visibility authority
  
  Status: LayerDetailManager computes all visibility properties

Phase 4: Renderer Cleanup
  □ Remove getChildNodeOpacity() method
  □ Update drawNode() to apply DetailState directly
  □ Remove fallback logic
  □ Make DetailState mandatory (no ?? defaults)
  
  Status: Renderer is pure application layer

Phase 5: Debug Visualization
  □ Update ZoomDebugWidget to show 5 segment boundaries
  □ Use getLayerWindowZoom() to avoid conversion
  □ Color-code by mode
  
  Status: Debug visibility into mode system

Phase 6: Testing
  □ Test constraint: L(n).collapsingMax == L(n+1).fadingInMin
  □ Test: optimal centered in EXPANDED segment
  □ Test: no gaps/overlaps in transitions
  
  Status: Constraints mathematically verified

================================================================================
KEY PRINCIPLES
================================================================================

1. SINGLE SOURCE OF TRUTH
   Mode determines all properties.
   No contradictions (e.g., visible=false but opacity=1 can't happen).

2. NO VISIBILITY LOGIC IN RENDERER
   Renderer never decides what should be visible.
   Renderer only applies what LayerDetailManager says.

3. ZOOM COORDINATES INTERNALLY
   ScaleBar uses zoom space internally (natural log space arithmetic).
   Scale exposed only in API for backward compatibility.

4. EXPLICIT SEGMENTS
   Window divided into 5 regions with mathematical constraints.
   Each region has specific properties.

5. LAYERED RESPONSIBILITY
   ScaleBar: geometry
   LayerDetailManager: logic/mode
   Renderer: application/drawing

================================================================================
CALL CHAIN FOR RENDERING
================================================================================

GraphManager.update()
    ↓
    for entity in visibleEntities:
        ↓
        detailState = layerDetailManager.getDetailStateAtZoom(entity, zoom)
          ↓
          segments = scaleBar.getLayerWindowSegments(layer)
          ↓
          mode = determinePresentationMode(zoom, segments)
          ↓
          return DetailState { visible, opacity, ... } derived from mode
        ↓
        if (detailState.visible) {
            renderer.drawNode(entity, detailState)
              ↓
              apply detailState properties mechanically
              ↓
              draw graphics
        }

================================================================================
VALIDATION CHECKLIST
================================================================================

After implementation:

Coordinate System:
  ✓ ScaleBar uses zoom internally, no conversion on every call
  ✓ ZoomDebugWidget uses getLayerWindowZoom() directly
  ✓ No bidirectional scale↔zoom conversion in hot paths

Visibility Logic:
  ✓ LayerDetailManager.getDetailStateAtZoom() computes all properties
  ✓ DetailState is complete package (no fallbacks needed)
  ✓ Renderer.drawNode() never calls getChildNodeOpacity()
  ✓ Renderer.drawNode() applies detailState directly

Mode System:
  ✓ 5 presentation modes defined
  ✓ determinePresentationMode() works correctly
  ✓ Mode→property helpers correctly implemented
  ✓ ZoomDebugWidget displays mode regions

Tests:
  ✓ L(n).collapsingMax == L(n+1).fadingInMin for all adjacent layers
  ✓ Optimal centered in EXPANDED segment in log space
  ✓ No gaps or overlaps in transitions
  ✓ Mode transitions happen at correct zoom levels

================================================================================
