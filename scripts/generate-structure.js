#!/usr/bin/env node

/**
 * Automatically generates CODE_STRUCTURE.md
 * Lists all source files with their classes/functions
 */

const fs = require('fs');
const path = require('path');

const SRC_DIR = path.join(__dirname, '../src');
const OUTPUT_FILE = path.join(__dirname, '../CODE_STRUCTURE.md');

function getAllTsFiles(dir) {
    const files = [];
    const items = fs.readdirSync(dir);
    
    for (const item of items) {
        const fullPath = path.join(dir, item);
        const stat = fs.statSync(fullPath);
        
        if (stat.isDirectory()) {
            files.push(...getAllTsFiles(fullPath));
        } else if (item.endsWith('.ts') && !item.endsWith('.d.ts')) {
            files.push(fullPath);
        }
    }
    
    return files;
}

function extractExports(filePath) {
    const content = fs.readFileSync(filePath, 'utf-8');
    const lines = content.split('\n');
    const exports = [];
    
    for (const line of lines) {
        // Match: export class ClassName
        const classMatch = line.match(/^export\s+(abstract\s+)?class\s+(\w+)/);
        if (classMatch) {
            const isAbstract = classMatch[1] ? 'abstract ' : '';
            exports.push(`${isAbstract}class ${classMatch[2]}`);
            continue;
        }
        
        // Match: export interface InterfaceName
        const interfaceMatch = line.match(/^export\s+interface\s+(\w+)/);
        if (interfaceMatch) {
            exports.push(`interface ${interfaceMatch[1]}`);
            continue;
        }
        
        // Match: export type TypeName
        const typeMatch = line.match(/^export\s+type\s+(\w+)/);
        if (typeMatch) {
            exports.push(`type ${typeMatch[1]}`);
            continue;
        }
        
        // Match: export function functionName
        const functionMatch = line.match(/^export\s+function\s+(\w+)/);
        if (functionMatch) {
            exports.push(`function ${functionMatch[1]}`);
            continue;
        }
        
        // Match: export const CONSTANT_NAME
        const constMatch = line.match(/^export\s+const\s+(\w+)/);
        if (constMatch) {
            exports.push(`const ${constMatch[1]}`);
            continue;
        }
    }
    
    return exports;
}

function extractMethods(filePath) {
    const content = fs.readFileSync(filePath, 'utf-8');
    const lines = content.split('\n');
    const methods = [];
    let insideClass = false;
    let braceDepth = 0;
    
    for (const line of lines) {
        // Track class definition
        if (line.match(/^(export\s+)?(abstract\s+)?class\s+\w+/)) {
            insideClass = true;
            braceDepth = 0;
        }
        
        // Track braces
        const openBraces = (line.match(/\{/g) || []).length;
        const closeBraces = (line.match(/\}/g) || []).length;
        braceDepth += openBraces - closeBraces;
        
        if (insideClass && braceDepth > 0) {
            // Match public/private/abstract/static methods
            const methodMatch = line.match(/^\s+(abstract\s+)?(static\s+)?(private\s+|public\s+)?(\w+)\s*\([^)]*\)\s*:\s*(.+?)(;|\{)/);
            if (methodMatch) {
                const isAbstract = methodMatch[1] ? 'abstract ' : '';
                const isStatic = methodMatch[2] ? 'static ' : '';
                const visibility = methodMatch[3] ? methodMatch[3].trim() : 'public';
                const name = methodMatch[4];
                const returnType = methodMatch[5].trim();
                
                // Skip constructor
                if (name === 'constructor') continue;
                
                methods.push(`${isAbstract}${isStatic}${visibility} ${name}(): ${returnType}`);
            }
        }
        
        if (insideClass && braceDepth === 0 && line.includes('}')) {
            insideClass = false;
        }
    }
    
    return methods;
}

function generateMarkdown() {
    const files = getAllTsFiles(SRC_DIR).sort();
    
    let markdown = '# Code Structure\n\n';
    markdown += '*Auto-generated by `npm run generate-structure`*\n\n';
    markdown += '---\n\n';
    
    for (const filePath of files) {
        const relativePath = path.relative(path.join(__dirname, '..'), filePath);
        const exports = extractExports(filePath);
        const methods = extractMethods(filePath);
        
        markdown += `## ${relativePath}\n\n`;
        
        if (exports.length > 0) {
            markdown += '**Exports:**\n';
            for (const exp of exports) {
                markdown += `- ${exp}\n`;
            }
            markdown += '\n';
        }
        
        if (methods.length > 0) {
            markdown += '**Methods:**\n';
            for (const method of methods) {
                markdown += `- ${method}\n`;
            }
            markdown += '\n';
        }
        
        if (exports.length === 0 && methods.length === 0) {
            markdown += '*No exports*\n\n';
        }
        
        markdown += '---\n\n';
    }
    
    return markdown;
}

function main() {
    console.log('Generating code structure documentation...');
    const markdown = generateMarkdown();
    fs.writeFileSync(OUTPUT_FILE, markdown);
    console.log(`âœ“ Generated ${OUTPUT_FILE}`);
}

main();
